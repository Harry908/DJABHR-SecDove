@startuml
title Sequence: Messaging with Socket.IO

actor Client
participant "MessagesRoutes" as Msg
participant "DB" as DB
participant "Socket.IO (io)" as IO

== Send Message ==
Client -> Msg: POST /api/messages\n{ conversation_id, content_key_number, encrypted_msg_content }
Msg -> DB: SELECT id FROM conversations WHERE id=? AND username=?
DB --> Msg: row or null
Msg -> DB: INSERT INTO messages(...)
DB --> Msg: { id, created_at }
Msg -> IO: to("conversation:<id>").emit('new-message', messageData)
Msg --> Client: 201 { message, messageData }

== Get Messages ==
Client -> Msg: GET /api/messages/:conversationId?limit&offset
Msg -> DB: SELECT ... FROM messages WHERE conversation_id=? AND is_deleted=0 ORDER BY created_at ASC LIMIT ? OFFSET ?
DB --> Msg: rows
Msg -> DB: SELECT COUNT(*) AS total WHERE conversation_id=? AND is_deleted=0
DB --> Msg: { total }
Msg --> Client: 200 { messages, pagination }

== Update Message ==
Client -> Msg: PUT /api/messages/:messageId { encrypted_msg_content }
Msg -> DB: SELECT id, conversation_id FROM messages WHERE id=?
DB --> Msg: row
Msg -> DB: SELECT id FROM conversations WHERE id=? AND username=?
DB --> Msg: row
Msg -> DB: UPDATE messages SET encrypted_msg_content=?, updated_at=? WHERE id=?
Msg --> Client: 200 { message: 'Message updated successfully', messageData }

== Delete Message ==
Client -> Msg: DELETE /api/messages/:messageId
Msg -> DB: SELECT id, conversation_id FROM messages WHERE id=?
DB --> Msg: row
Msg -> DB: SELECT id FROM conversations WHERE id=? AND username=?
DB --> Msg: row
Msg -> DB: UPDATE messages SET is_deleted=1 WHERE id=?
Msg --> Client: 200 { message: 'Message deleted successfully' }

== Recent Messages ==
Client -> Msg: GET /api/messages/recent/all?limit
Msg -> DB: SELECT DISTINCT id FROM conversations WHERE username=?
DB --> Msg: ids
Msg -> DB: SELECT ... FROM messages WHERE conversation_id IN (?) AND is_deleted=0 ORDER BY created_at DESC LIMIT ?
DB --> Msg: rows
Msg --> Client: 200 { messages }

@enduml

