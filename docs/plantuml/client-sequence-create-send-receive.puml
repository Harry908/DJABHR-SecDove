@startuml
title Client Sequence: Create Conversation, Send and Receive Message

actor User
participant "ConversationsContext" as CC
participant "MessagesContext" as MC
participant "WebSocketContext" as WS
participant "CryptoUtils" as CU
participant "APIClient" as API

== Create Conversation ==
User -> CC: createConversation([participants])
CC -> API: GET /contacts/:username/public-key (for others)
API --> CC: { public_key }
CC -> CU: generateContentKey()
CC -> CU: encryptContentKey(contentKey, publicKey) x each participant
CC -> API: POST /conversations { conversation_entries: [{id, content_key_number, username, encrypted_content_key}...] }
API --> CC: { conversation }
CC -> cache: store contentKey by conversationId

== Load Messages ==
User -> MC: loadMessages(conversationId)
MC -> CC: getContentKey(conversationId)
MC -> API: GET /messages/:conversationId
API --> MC: { messages[encrypted] }
MC -> CU: decryptMessage(encrypted, key) x each
MC --> User: decrypted messages

== Send Message ==
User -> MC: sendMessage(conversationId, content)
MC -> CC: getContentKey(conversationId)
MC -> CU: encryptMessage({sender, timestamp, content}, key)
MC -> API: POST /messages { conversation_id, content_key_number, encrypted_msg_content }
API --> MC: { messageData }
MC -> state: add to local messages

== Receive Real-time Message ==
WS -> MC: 'new-message' { id, conversation_id, encrypted_msg_content, created_at }
MC -> CC: getContentKey(conversationId)
MC -> CU: decryptMessage(encrypted, key)
MC -> state: add to local messages (dedupe)
MC --> User: updated message list

@enduml

